package mps

import "io"

// ExtractEventType is an enum representing the type of event that can occur during message extraction.
type ExtractEventType int

const (
	// MessageReceived indicates that one more more messages have been successfully extracted.
	MessageReceived ExtractEventType = iota
	// ExtractionError indicates that an error occurred during the extraction process.
	ExtractionError
	// StreamClosed indicates that the stream has been closed.  If the remote closes the stream (for connection-oriented transports), the local connection object is also closed.
	StreamClosed
)

// ExtractionEvent represents an event that occurs during the message extraction process.
type ExtractionEvent struct {
	Type    ExtractEventType
	Message []byte
	Reader  io.Reader
	Error   error
}

// An Extractor is something that can read from a transport that carries messages, where all messages are of the same L7 type.
type Extractor interface {
	StartExtracting(reader io.Reader, eventChannel chan<- *ExtractionEvent)
}

// MaximumAllowedLengthExceededError is an error that indicates that the maximum allowed length for a message has been exceeded.  It may be
// generated by a LengthExtractorMethod.
type MaximumAllowedLengthExceededError struct{}

func (e *MaximumAllowedLengthExceededError) Error() string {
	return "Maximum allowed length exceeded"
}

// LengthExtractorMethod is used by an Extractor for a stream-oriented transport.  On each read of the transport socket, data are added to an accumulating
// buffer.  This method receives that buffer.  It is expected to return the length of the next message in the buffer, or an error.  If the length is greater than the maximum allowed length, it should return
// MaximumAllowedLengthExceededError.  If the length cannot yet be determined, lengthOfNextMessage should be 0 and err should be nil.
type LengthExtractorMethod func(accumulatedData []byte) (lengthOfNextMessage uint64, err error)

// A StreamExtractor is an Extractor that reads from a stream-oriented transport.  It uses a LengthExtractorMethod to determine the length of the next message in the stream.
type StreamExtractor struct {
	lengthExtractor LengthExtractorMethod
	bufferSizeHint  int
	pendingData     []byte
}

// NewStreamExtractor creates a new StreamExtractor with the provided LengthExtractorMethod.
func NewStreamExtractor(lengthExtractor LengthExtractorMethod) *StreamExtractor {
	return &StreamExtractor{
		lengthExtractor: lengthExtractor,
		bufferSizeHint:  9126,
		pendingData:     nil,
	}
}

// SetBufferSizeHint is used to set the read buffer size in StartExtracting.  By default, it is 9126.  Each read from the transport reader will return
// up to this number of bytes.  This is merely an optimization.  A separate buffer contains data accumulated across reads.  This must be set before
// StartExtracting is called to be effective.  It returns the StreamExtractor for method chaining, if desired.
func (e *StreamExtractor) SetBufferSizeHint(size int) *StreamExtractor {
	if size > 0 {
		e.bufferSizeHint = size
	}

	return e
}

// StartExtracting begins the message extraction process from the reader, which should be a stream-oriented transport.  As events occur, they
// are sent to the provided eventChannel.  The event type will be MessageReceived if a complete message has been received, ExtractionError if an
// error occurs, or StreamClosed if the stream has been closed.  The reader will be closed if the remote closes the stream.  On an ExtractionError,
// the reader state is undefined, and the reader should be used further.
func (e *StreamExtractor) StartExtracting(reader io.Reader, eventChannel chan<- *ExtractionEvent) {
	e.pendingData = make([]byte, 0, e.bufferSizeHint)
	readBuffer := make([]byte, e.bufferSizeHint)

	for {
		bytesRead, err := reader.Read(readBuffer)
		e.pendingData = append(e.pendingData, readBuffer[:bytesRead]...)

		if err != nil && err != io.EOF {
			eventChannel <- &ExtractionEvent{
				Type:   ExtractionError,
				Reader: reader,
				Error:  err,
			}
			return
		}

		for {
			nextMessageLength, err := e.lengthExtractor(e.pendingData)
			if err != nil {
				eventChannel <- &ExtractionEvent{
					Type:   ExtractionError,
					Reader: reader,
					Error:  err,
				}
				return
			}

			if nextMessageLength > 0 && nextMessageLength <= uint64(len(e.pendingData)) {
				message := make([]byte, nextMessageLength)
				copy(message, e.pendingData[:nextMessageLength])
				eventChannel <- &ExtractionEvent{
					Type:    MessageReceived,
					Message: message,
					Reader:  reader,
				}
				e.pendingData = e.pendingData[nextMessageLength:]
			} else {
				break
			}
		}

		if err == io.EOF {
			eventChannel <- &ExtractionEvent{
				Type:   StreamClosed,
				Reader: reader,
				Error:  err,
			}

			return
		}
	}
}

type DatagramExtractor struct {
	bufferSizeHint int
}

func NewDatagramExtractor() *DatagramExtractor {
	return &DatagramExtractor{
		bufferSizeHint: 65535,
	}
}

func (e *DatagramExtractor) SetBufferSizeHint(size int) {
	if size > 0 {
		e.bufferSizeHint = size
	}
}

func (e *DatagramExtractor) StartExtracting(reader io.Reader, eventChannel chan<- *ExtractionEvent) {
	for {
		readBuffer := make([]byte, e.bufferSizeHint)

		bytesRead, err := reader.Read(readBuffer)
		if err != nil && err != io.EOF {
			eventChannel <- &ExtractionEvent{
				Type:   ExtractionError,
				Reader: reader,
				Error:  err,
			}
			return
		}

		eventChannel <- &ExtractionEvent{
			Type:    MessageReceived,
			Message: readBuffer[:bytesRead],
			Reader:  reader,
		}

		if err == io.EOF {
			eventChannel <- &ExtractionEvent{
				Type:   StreamClosed,
				Reader: reader,
				Error:  err,
			}
			return
		}
	}
}
