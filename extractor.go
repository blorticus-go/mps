package mps

import (
	"errors"
	"io"
)

// ExtractionEventType is an enum representing the type of event that can occur during message extraction.
type ExtractionEventType int

const (
	// MessageReceived indicates that one more more messages have been successfully extracted.
	MessageReceived ExtractionEventType = iota
	// ExtractionError indicates that an error occurred during the extraction process.
	ExtractionError
	// FlowClosed indicates that the stream has been closed.  If the remote closes the stream (for connection-oriented transports), the local connection object is also closed.
	FlowClosed
)

// String produces a human-readable string for an ExtractionEventType
func (t ExtractionEventType) String() string {
	switch t {
	case MessageReceived:
		return "MessageReceived"
	case ExtractionError:
		return "ExtractionError"
	case FlowClosed:
		return "StreamClosed"
	}

	return ""
}

// ExtractionEvent represents an event that occurs during the message extraction process.
type ExtractionEvent struct {
	Type    ExtractionEventType
	Message []byte
	Reader  io.Reader
	Error   error
}

// An Extractor is something that can read from a transport that carries messages, where all messages are of the same L7 type.
type Extractor interface {
	StartExtracting(reader io.Reader, eventChannel chan<- *ExtractionEvent)
}

// ErrMaximumAllowedLengthExceeded is an error that indicates that the maximum allowed length for a message has been exceeded.  It may be
// generated by a LengthExtractorMethod.
var ErrMaximumAllowedLengthExceeded = errors.New("maximum allowed length exceeded")

// ErrMessageReadTooLong is raised during extraction when more data are buffered than the maximum allowed for that extractor.
var ErrMessageReadTooLong = errors.New("message too long")

// LengthExtractorMethod is used by an Extractor for a stream-oriented transport.  On each read of the transport socket, data are added to an accumulating
// buffer.  This method receives that buffer.  It is expected to return the length of the next message in the buffer, or an error.  If the length is greater than the maximum allowed length, it should return
// MaximumAllowedLengthExceededError.  If the length cannot yet be determined, lengthOfNextMessage should be 0 and err should be nil.
type LengthExtractorMethod func(accumulatedData []byte) (lengthOfNextMessage uint64, err error)

// A StreamExtractor is an Extractor that reads from a stream-oriented transport.  It uses a LengthExtractorMethod to determine the length of the next message in the stream.
type StreamExtractor struct {
	lengthExtractor             LengthExtractorMethod
	maximumAllowedMessageLength uint
}

// NewStreamExtractor creates a new StreamExtractor with the provided LengthExtractorMethod.
func NewStreamExtractor(lengthExtractor LengthExtractorMethod, maximumAllowedMessageLength uint) *StreamExtractor {
	return &StreamExtractor{
		lengthExtractor:             lengthExtractor,
		maximumAllowedMessageLength: maximumAllowedMessageLength,
	}
}

// StartExtracting begins the message extraction process from the reader, which should be a stream-oriented transport.  As events occur, they
// are sent to the provided eventChannel.  The event type will be MessageReceived if a complete message has been received, ExtractionError if an
// error occurs, or StreamClosed if the stream has been closed.  The reader will be closed if the remote closes the stream.  On an ExtractionError,
// the reader state is undefined, and the reader should be used further.
func (e *StreamExtractor) StartExtracting(reader io.Reader, eventChannel chan<- *ExtractionEvent) {
	pendingDataBuffer := NewFixedSlidingBuffer(e.maximumAllowedMessageLength)

	for {
		_, err := pendingDataBuffer.ReadOnceIntoPendingBuffer(reader)

		if err != nil && err != io.EOF {
			eventChannel <- &ExtractionEvent{
				Type:   ExtractionError,
				Reader: reader,
				Error:  err,
			}
			return
		}

		for {
			nextMessageLength, err := e.lengthExtractor(pendingDataBuffer.Peek())
			if err != nil {
				eventChannel <- &ExtractionEvent{
					Type:   ExtractionError,
					Reader: reader,
					Error:  err,
				}
				return
			}

			if nextMessageLength > 0 && nextMessageLength <= uint64(pendingDataBuffer.Length()) {
				message := make([]byte, nextMessageLength)
				pendingDataBuffer.Read(message)

				eventChannel <- &ExtractionEvent{
					Type:    MessageReceived,
					Message: message,
					Reader:  reader,
				}
			} else {
				break
			}
		}

		if err == io.EOF {
			eventChannel <- &ExtractionEvent{
				Type:   FlowClosed,
				Reader: reader,
				Error:  err,
			}

			return
		}
	}
}

type DatagramExtractor struct {
	bufferSizeHint int
}

func NewDatagramExtractor() *DatagramExtractor {
	return &DatagramExtractor{
		bufferSizeHint: 65535,
	}
}

func (e *DatagramExtractor) SetBufferSizeHint(size int) {
	if size > 0 {
		e.bufferSizeHint = size
	}
}

func (e *DatagramExtractor) StartExtracting(reader io.Reader, eventChannel chan<- *ExtractionEvent) {
	for {
		readBuffer := make([]byte, e.bufferSizeHint)

		bytesRead, err := reader.Read(readBuffer)
		if err != nil && err != io.EOF {
			eventChannel <- &ExtractionEvent{
				Type:   ExtractionError,
				Reader: reader,
				Error:  err,
			}
			return
		}

		eventChannel <- &ExtractionEvent{
			Type:    MessageReceived,
			Message: readBuffer[:bytesRead],
			Reader:  reader,
		}

		if err == io.EOF {
			eventChannel <- &ExtractionEvent{
				Type:   FlowClosed,
				Reader: reader,
				Error:  err,
			}
			return
		}
	}
}
